// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"tBppkQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
