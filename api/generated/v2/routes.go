// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
