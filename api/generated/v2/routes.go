// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
