// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
