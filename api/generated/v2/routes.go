// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
