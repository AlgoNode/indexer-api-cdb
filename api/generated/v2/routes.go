// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "online-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "online-only", ctx.QueryParams(), &params.OnlineOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter online-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
