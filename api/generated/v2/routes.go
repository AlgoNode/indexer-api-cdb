// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jDA/mT2efPz/AQAA///vjMzzdaUBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
