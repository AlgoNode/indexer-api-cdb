// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
