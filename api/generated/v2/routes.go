// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/+1p/kBViAEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
