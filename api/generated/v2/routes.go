// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
