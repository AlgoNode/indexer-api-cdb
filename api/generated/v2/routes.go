// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"FV0smMrszAjzk5PHk4//PwAA//9SW782m4ABAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
