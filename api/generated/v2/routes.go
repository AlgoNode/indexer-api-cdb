// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
