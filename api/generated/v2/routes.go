// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// ------------- Optional query parameter "updates" -------------

	err = runtime.BindQueryParameter("form", false, false, "updates", ctx.QueryParams(), &params.Updates)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updates: %s", err))
	}

	// ------------- Optional query parameter "participation" -------------

	err = runtime.BindQueryParameter("form", false, false, "participation", ctx.QueryParams(), &params.Participation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter participation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"jDA/OXk8+fT/AgAA//+iEaM6j8ABAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
