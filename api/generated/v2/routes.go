// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/block-headers)
	SearchForBlockHeaders(ctx echo.Context, params SearchForBlockHeadersParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlockHeaders converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlockHeaders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlockHeadersParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposers" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposers", ctx.QueryParams(), &params.Proposers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposers: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// ------------- Optional query parameter "absent" -------------

	err = runtime.BindQueryParameter("form", false, false, "absent", ctx.QueryParams(), &params.Absent)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter absent: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlockHeaders(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/block-headers", wrapper.SearchForBlockHeaders, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
