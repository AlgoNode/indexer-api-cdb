// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	LookupApplicationBoxByIDAndName(ctx echo.Context, applicationId uint64, params LookupApplicationBoxByIDAndNameParams) error
	// Get box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	SearchForApplicationBoxes(ctx echo.Context, applicationId uint64, params SearchForApplicationBoxesParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks)
	SearchForBlocks(ctx echo.Context, params SearchForBlocksParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64, params LookupBlockParams) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "account-id", runtime.ParamLocationPath, ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationBoxByIDAndName converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationBoxByIDAndName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationBoxByIDAndNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationBoxByIDAndName(ctx, applicationId, params)
	return err
}

// SearchForApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationBoxesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplicationBoxes(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// SearchForBlocks converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForBlocks(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForBlocksParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "proposer" -------------

	err = runtime.BindQueryParameter("form", false, false, "proposer", ctx.QueryParams(), &params.Proposer)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter proposer: %s", err))
	}

	// ------------- Optional query parameter "expired" -------------

	err = runtime.BindQueryParameter("form", false, false, "expired", ctx.QueryParams(), &params.Expired)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter expired: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForBlocks(ctx, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round-number", runtime.ParamLocationPath, ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber, params)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "group-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "group-id", ctx.QueryParams(), &params.GroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter group-id: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET(baseURL+"/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET(baseURL+"/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET(baseURL+"/v2/applications", wrapper.SearchForApplications, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.LookupApplicationBoxByIDAndName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.SearchForApplicationBoxes, m...)
	router.GET(baseURL+"/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET(baseURL+"/v2/assets", wrapper.SearchForAssets, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET(baseURL+"/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET(baseURL+"/v2/blocks", wrapper.SearchForBlocks, m...)
	router.GET(baseURL+"/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET(baseURL+"/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET(baseURL+"/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"8eTD/w8AAP//iQizO9CNAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
